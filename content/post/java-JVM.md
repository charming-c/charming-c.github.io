---
title: Java-JVM
date: 2022-04-21
draft: false

---

# 一、什么是JVM？

## 1. 从jdk说起

在初次运行Java代码之前我们都要下载一个叫做jdk的东西，并且要配置好环境变量，这样我们的java代码才能跑起来，达到我们想要的效果。简单的说，jdk就是用于支持java程序开发的最小环境，主要由Java程序设计语言、Java虚拟机、Java类库组成。jdk是java的核心，包含JRE和一些java工具（比如javac，java，jdb等）以及java的基础类库。

JRE叫做Java运行时环境，在jdk的安装目录下，里面又有bin和lib两个文件夹，可以简单地理解成bin里面的就是jvm，而这个lib里装的是JVM工作时所需要的类库。



![](https://tva1.sinaimg.cn/large/008eGmZEly1goqerxazlnj30im0bdjr9.jpg)

## 2.JVM的作用和好处

JVM是java能实现跨平台开发的核心，在一开始推出java的时候，开发者打出的口号是“一次编译，到处执行”，而能够实现这一目标的根源就是JVM，所有的Java程序在编译器编译过后，首先会编译成一个.class文件，这种类文件就会在虚拟机中解释运行，再通过虚拟机将程序解释给操作系统去执行，这样在不同的操作系统上我们只需要安装不同的虚拟机就可以运行同样的一份编译好的java程序。

java不像c++、c语言那样编译后直接与操作系统联系，跑在我们的电脑上，而是根据一个叫做java虚拟机的东西，用它来解释我们编译好的java代码，生成相应的机器语言，交由操作系统执行，从而运行程序。

# 二、JVM的自动内存管理

我们在编写c、c++程序的时候，所有关于动态分配的内存，都需要我们在程序结束之前将其销毁掉，否则就可能会出现相应的内存泄漏。而对于java来说，在虚拟机自动内存管理机制的帮助下，不需要再为每一个new操作去配对相应的delete代码，这样就大大减少我们的工作量以及避免了大多数内存泄漏和溢出方面的问题。

## 1. JVM运行时数据区域

> Java虚拟机在执行java程序中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些则是依赖于用户的启动和结束而建立和销毁，Java虚拟机所管理的内存主要包括以下几个运行时数据区域：

![](https://tva1.sinaimg.cn/large/008eGmZEly1goqeui77gmj30fx08ojs5.jpg)

## 2. 程序计数器（Program Counter Register）

程序计数器时一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。在字节码解释器工作时就是通过改变这个计数器的值来选取下一条要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都是要依赖这个计数器来完成。

比如，Java虚拟机的多线程就是通过线程轮流切换、分配处理器的执行时间的方式来实现的，在任何一个确定的时刻，一个单核处理器都只会执行一条线程中的一个指令。而程序计数器是为了指示下一条字节码指令在哪里，为了在线程切换以后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各条线程的之间的计数器互不影响，独立储存。这类的内存区域我们称为“线程私有的”。

注意：当正在执行的是本地方法（native），这个计数器的值此时为null

## 3.Java虚拟机栈（Java Virtual Machine Stack）

和程序计数器一样，栈也是线程私有的，生命周期和线程相同。java栈描述的是java方法执行的线程内存模型：每个方法被执行的时候就会先创建一个栈帧并放入虚拟机栈中，在方法执行完毕时再从虚拟机栈中移除该栈帧。什么是栈帧？它主要用来存储局部变量表、操作数栈、动态链接、方法出口等信息。方法在执行时就会有各种存储信息入栈出栈，一个栈帧就包含了一个java方法的执行的所有信息。

局部变量表存放了编译期可知的各种Java虚拟机基本数据类型、对象引用（reference）和returnAddress类型，局部变量表所需的内存空间在编译期完成分配，在方法运行期不会改变局部变量表的大小。在JVM规范中并没有对虚拟机栈空间的大小做限制，可以设置为固定大小的，也可以设置为可扩展的。但是在规范中定义了两种异常情况：

- 如果计算时请求的栈空间大于虚拟机栈的最大值，则会抛出`StackOverflowError`异常；
- 如果虚拟机栈设置为可扩展的并且无法再获取更多内存时，则会抛出`OutOfMemoryError`异常。

## 4.本地方法栈（Native Stack Stacks）

本地方法栈与虚拟机栈发挥的作用是非常相似的，其区别就是这里执行的是native方法，而虚拟机栈里执行的是java方法，在一些虚拟机中，比如Hot-Spot，本地方法栈和虚拟机栈是放到一起的，他们的相似性可见一斑。

## 5. Java堆（Java Heap）

对于java程序来说，堆是虚拟机所管理的内存的最大的一块，Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的是存放对象实例，Java世界里所有的对象实例都在这里分配内存。

Java堆是垃圾收集管理的内存区域，从分配内存的角度来看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区，以提升对象分配的效率，但是原则上来说，Java堆里面对象是杂乱无章的，Java堆被细分的目的是为了更好的回收内存，或者更快的分配内存。Java堆是可以被实现成固定大小的，也是可以扩展的。但不管是何种方式，规范中还是定义了一种异常场景：

- 如果计算需要更多的堆空间而无法满足时，则会抛出`OutOfMemoryError`异常。

![](https://tva1.sinaimg.cn/large/008eGmZEly1goqh72zmtfj30oe0engmf.jpg)

## 6.方法区（Method Area）

1. 方法区又被称为静态区，是程序中永远唯一的元素存储区域。和堆一样，是各个线程共享的内存区域。它用于存储已被虚拟机加载的类信息（类的方法代码，变量名，方法名，访问权限，返回值等）、常量、静态变量、即时编译器编译后的代码等数据。            

2. Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样 不需要连续的内存和可以选择固定大小或者可扩展之外，还可以选择不实现垃圾回收。 
    这区域的内存回收目标主要是针对常量池的回收和类型的卸载，一般而言，这个区域的内存回收比较难以令人满意，尤其是类型的回收，条件相当苛刻，但是这部分区域的内存回收确实是必要的。

3. 很多开发者更愿意把方法区称为“永久代”(Permanent Generation)「总是存放不会轻易改变的内容」。在目前已经发布的JDK 1.7 的HotSpot中，已经把原本放在永久代的字符串常量池移至堆中。
4. 运行时常量池(Runtime Constant Pool)是方法区的一部分。（对于普通常量池有一个重要特征就是具备动态性，Java并不制定常量只能在编译期才能产生，运行时可以将新的常量放入池中。
   1. Eg:`String.intern()`是一个Native(本地)方法，它的作用是如果字符串常量池已经包含一个等于此String对象的字符串，则返回字符串常量池中这个字符串的引用, 否则将当前String对象的引用地址（堆中）添加到字符串常量池中并返回。

```java
public static void main(String[] args){
        String str1 = new StringBuilder("123").append("456").toString();
        System.out.println(str1.intern() == str1);

        String str2 = new StringBuilder("ja").append("va").toString();
        System.out.println(str2.intern() == str2);
    }
```

